# app.py
import os
import threading
import queue
import uuid
import time
import http.cookiejar as cookiejar
from flask import Flask, render_template, request, jsonify, send_from_directory
from yt_dlp import YoutubeDL

app = Flask(__name__, template_folder="templates", static_folder="static")

BASE_DIR = os.path.dirname(__file__)
DOWNLOAD_DIR = os.path.join(BASE_DIR, "downloads")
os.makedirs(DOWNLOAD_DIR, exist_ok=True)

# In-memory task store
tasks = {}          # task_id -> task dict
task_queue = queue.Queue()

# Try import browser_cookie3 (optional)
try:
    import browser_cookie3
    HAVE_BROWSER_COOKIE3 = True
except Exception:
    HAVE_BROWSER_COOKIE3 = False

# Helper: write cookies from a cookiejar-like iterable to Netscape format
def write_netscape_cookies(cookie_iterable, out_path):
    """
    cookie_iterable: iterable of cookie objects with attributes:
        domain, path, secure (bool), expires (int or None), name, value
    out_path: file to write (Netscape cookie format)
    """
    header = "# Netscape HTTP Cookie File\n# This file was generated by app.py\n\n"
    lines = []
    for c in cookie_iterable:
        domain = c.domain
        # cookies from some libs may have leading dot; Netscape format allows it
        include_subdomains = "TRUE" if domain.startswith('.') or getattr(c, 'domain_specified', False) else "FALSE"
        path = c.path or "/"
        secure = "TRUE" if getattr(c, "secure", False) else "FALSE"
        expiry = str(int(getattr(c, "expires", 0) or 0))
        name = c.name
        value = c.value
        lines.append("\t".join([domain, include_subdomains, path, secure, expiry, name, value]))
    with open(out_path, "w", encoding="utf-8") as fh:
        fh.write(header)
        fh.write("\n".join(lines))
    try:
        os.chmod(out_path, 0o600)
    except Exception:
        pass
    return out_path

def dump_browser_cookies_for_youtube(task_id):
    """
    Attempts to extract browser cookies for YouTube using browser_cookie3 and
    write them to a Netscape cookie file in DOWNLOAD_DIR.
    Returns the path to the cookie file on success, or None on failure.
    """
    if not HAVE_BROWSER_COOKIE3:
        return None
    try:
        # Try multiple browser helpers (chrome, edge, firefox, brave) — take the first that works
        cj = None
        for fn in (getattr(browser_cookie3, 'chrome', None),
                   getattr(browser_cookie3, 'edge', None),
                   getattr(browser_cookie3, 'firefox', None),
                   getattr(browser_cookie3, 'brave', None)):
            if not fn:
                continue
            try:
                candidate = fn()
                if candidate:
                    cj = candidate
                    break
            except Exception:
                continue
        if not cj:
            return None

        # Filter cookies to those that are for youtube.com (and related google domains)
        youtube_cookies = [c for c in cj if ("youtube.com" in getattr(c, "domain", "") or "google.com" in getattr(c, "domain", ""))]
        if not youtube_cookies:
            # If nothing found specifically for YouTube, fallback to entire cookiejar
            youtube_cookies = list(cj)

        cookie_path = os.path.join(DOWNLOAD_DIR, f"browser_cookies_{task_id}.txt")
        write_netscape_cookies(youtube_cookies, cookie_path)
        return cookie_path
    except Exception:
        # don't crash the worker — return None so the task continues without cookies
        return None

# Worker thread processes tasks serially
def worker():
    while True:
        task_id = task_queue.get()
        if task_id is None:
            break
        task = tasks.get(task_id)
        if not task:
            task_queue.task_done()
            continue
        try:
            task['status'] = 'processing'
            if task['mode'] == 'single':
                _download_single(task_id, task)
            elif task['mode'] == 'playlist':
                _download_playlist(task_id, task)
            # if not set to cookie_required or error, mark as done
            if task.get('status') not in ('cookie_required', 'error'):
                task['status'] = 'done'
        except Exception as e:
            task['status'] = 'error'
            task['error'] = str(e)
        finally:
            task_queue.task_done()

worker_thread = threading.Thread(target=worker, daemon=True)
worker_thread.start()

# Generic progress hook factory
def make_progress_hook(task_id):
    def progress_hook(d):
        t = tasks.get(task_id)
        if not t:
            return

        status = d.get('status')
        info = d.get('info_dict') or {}
        p_idx = info.get('playlist_index') or d.get('playlist_index') or info.get('playlist_index')
        p_total = info.get('playlist_count') or d.get('playlist_count') or None

        if status == 'downloading':
            percent = d.get('percent')
            t['progress'] = {
                'status': 'downloading',
                'percent': round(percent, 2) if percent is not None else None,
                'speed': d.get('speed'),
                'eta': d.get('eta'),
                'filename': d.get('filename'),
                'item': p_idx,
                'of': p_total
            }
        elif status == 'finished':
            fn = d.get('filename')
            if fn:
                t.setdefault('files', []).append(os.path.basename(fn))
            t['progress'] = {
                'status': 'finished',
                'filename': fn,
                'item': p_idx,
                'of': p_total
            }
        elif status == 'error':
            t['progress'] = {'status': 'error', 'info': d}
    return progress_hook

# helper that attempts download and returns (success_bool, exception_or_none)
def _attempt_download(ydl_opts, url):
    try:
        with YoutubeDL(ydl_opts) as ydl:
            ydl.download([url])
        return True, None
    except Exception as e:
        return False, e

# Single video download
def _download_single(task_id, task):
    url = task['url']
    choice = task.get('choice', 'best')
    force_h264 = bool(task.get('force_h264', False))
    audio_format = task.get('audio_format', 'mp3')

    outtmpl = os.path.join(DOWNLOAD_DIR, '%(title)s [%(id)s].%(ext)s')

    ydl_opts = {
        'outtmpl': outtmpl,
        'noplaylist': True,
        'progress_hooks': [make_progress_hook(task_id)],
        'writesubtitles': False,
        'quiet': True,
        'no_warnings': True,
    }

    # Attach cookiefile if provided or try browser cookies
    cookiefile_path = task.get('cookiefile_path')
    if not cookiefile_path:
        # Prefer a cookies.txt in project root if present (user convenience)
        root_cookies = os.path.join(BASE_DIR, "cookies.txt")
        if os.path.exists(root_cookies):
            cookiefile_path = root_cookies
            task.setdefault('progress', {})['cookie_used'] = os.path.basename(cookiefile_path)
        else:
            # Try to auto-dump browser cookies if available (local machine)
            try:
                cookiefile_path = dump_browser_cookies_for_youtube(task_id)
                if cookiefile_path:
                    task.setdefault('progress', {})['cookie_used'] = os.path.basename(cookiefile_path)
            except Exception as e:
                # If cookie extraction fails, continue without cookies
                task.setdefault('progress', {})['cookie_error'] = str(e)
                cookiefile_path = None

    if cookiefile_path:
        ydl_opts['cookiefile'] = cookiefile_path

    if choice == 'audio':
        ydl_opts.update({
            'format': 'bestaudio/best',
            'postprocessors': [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': audio_format,
                'preferredquality': '192',
            }],
        })
    else:
        if choice == 'best':
            fmt = 'bestvideo+bestaudio/best'
        else:
            try:
                h = int(choice)
                fmt = f'bestvideo[height<={h}]+bestaudio/best'
            except Exception:
                fmt = 'bestvideo+bestaudio/best'
        ydl_opts['format'] = fmt
        ydl_opts['merge_output_format'] = 'mp4'

        if force_h264:
            ydl_opts['postprocessor_args'] = [
                '-c:v', 'libx264',
                '-preset', 'fast',
                '-crf', '23',
                '-c:a', 'aac',
                '-b:a', '192k'
            ]

    # Attempt download once normally
    success, exc = _attempt_download(ydl_opts, url)
    if success:
        return

    # If error contains the youtube cookie/auth message, handle it
    err_str = str(exc).lower()
    cookie_error_indicators = ("sign in to confirm", "use --cookies-from-browser", "sign in to confirm you", "sign-in to confirm")
    if any(ind in err_str for ind in cookie_error_indicators):
        # If root cookies exist now, try again silently using them
        root_cookies = os.path.join(BASE_DIR, "cookies.txt")
        if os.path.exists(root_cookies):
            # use root cookies and retry
            ydl_opts['cookiefile'] = root_cookies
            task.setdefault('progress', {})['cookie_used'] = os.path.basename(root_cookies)
            success2, exc2 = _attempt_download(ydl_opts, url)
            if success2:
                return
            # if retry failed, fall through to notify user below
            err_str = str(exc2).lower()
        # No root cookies or retry failed - tell user to export cookies.txt and place in project root
        task['status'] = 'cookie_required'
        task['progress'] = {
            'status': 'error',
            'error': 'youtube_requires_cookies',
            'message': ("YouTube requires a logged-in session (bot-check). "
                        "Please export cookies.txt from your browser (Netscape format), place it in the project root "
                        "where app.py is, then refresh the UI/page.")
        }
        return
    else:
        # Other error - set task error
        task['status'] = 'error'
        task['error'] = str(exc)
        return


# Playlist download
def _download_playlist(task_id, task):
    url = task['url']
    choice = task.get('choice', 'best')
    force_h264 = bool(task.get('force_h264', False))
    audio_format = task.get('audio_format', 'mp3')

    outtmpl = os.path.join(DOWNLOAD_DIR, '%(playlist_index)03d - %(title)s [%(id)s].%(ext)s')

    ydl_opts = {
        'outtmpl': outtmpl,
        'noplaylist': False,
        'progress_hooks': [make_progress_hook(task_id)],
        'writesubtitles': False,
        'quiet': True,
        'no_warnings': True,
    }

    # Attach cookiefile if provided or try browser cookies
    cookiefile_path = task.get('cookiefile_path')
    if not cookiefile_path:
        # Prefer a cookies.txt in project root if present (user convenience)
        root_cookies = os.path.join(BASE_DIR, "cookies.txt")
        if os.path.exists(root_cookies):
            cookiefile_path = root_cookies
            task.setdefault('progress', {})['cookie_used'] = os.path.basename(cookiefile_path)
        else:
            try:
                cookiefile_path = dump_browser_cookies_for_youtube(task_id)
                if cookiefile_path:
                    task.setdefault('progress', {})['cookie_used'] = os.path.basename(cookiefile_path)
            except Exception as e:
                task.setdefault('progress', {})['cookie_error'] = str(e)
                cookiefile_path = None

    if cookiefile_path:
        ydl_opts['cookiefile'] = cookiefile_path

    if choice == 'audio':
        ydl_opts.update({
            'format': 'bestaudio/best',
            'postprocessors': [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': audio_format,
                'preferredquality': '192',
            }],
        })
    else:
        if choice == 'best':
            fmt = 'bestvideo+bestaudio/best'
        else:
            try:
                h = int(choice)
                fmt = f'bestvideo[height<={h}]+bestaudio/best'
            except:
                fmt = 'bestvideo+bestaudio/best'
        ydl_opts['format'] = fmt
        ydl_opts['merge_output_format'] = 'mp4'

        if force_h264:
            ydl_opts['postprocessor_args'] = [
                '-c:v', 'libx264',
                '-preset', 'fast',
                '-crf', '23',
                '-c:a', 'aac',
                '-b:a', '192k'
            ]

    # Attempt download once normally
    success, exc = _attempt_download(ydl_opts, url)
    if success:
        return

    err_str = str(exc).lower()
    cookie_error_indicators = ("sign in to confirm", "use --cookies-from-browser", "sign in to confirm you", "sign-in to confirm")
    if any(ind in err_str for ind in cookie_error_indicators):
        root_cookies = os.path.join(BASE_DIR, "cookies.txt")
        if os.path.exists(root_cookies):
            ydl_opts['cookiefile'] = root_cookies
            task.setdefault('progress', {})['cookie_used'] = os.path.basename(root_cookies)
            success2, exc2 = _attempt_download(ydl_opts, url)
            if success2:
                return
            err_str = str(exc2).lower()
        task['status'] = 'cookie_required'
        task['progress'] = {
            'status': 'error',
            'error': 'youtube_requires_cookies',
            'message': ("YouTube requires a logged-in session (bot-check). "
                        "Please export cookies.txt from your browser (Netscape format), place it in the project root "
                        "where app.py is, then refresh the UI/page.")
        }
        return
    else:
        task['status'] = 'error'
        task['error'] = str(exc)
        return


# Routes
@app.route("/")
def index():
    return send_from_directory(BASE_DIR, "index.html")

from werkzeug.utils import secure_filename

ALLOWED_COOKIE_EXTS = {'.txt', '.cookies'}  # Netscape cookies usually .txt

@app.route("/start_download", methods=["POST"])
def start_download():
    """
    Accepts multipart/form-data which may include:
      - url (string)
      - mode (single|playlist)
      - choice (quality)
      - audio_format (mp3|m4a|...)
      - force_h264 (on|off or true/false)
      - cookiefile (file upload - optional, Netscape format)
    """
    if request.is_json:
        data = request.get_json()
        url = (data.get("url") or "").strip()
        mode = data.get("mode", "single")
        choice = data.get("choice", "best")
        audio_format = data.get("audio_format", "mp3")
        force_h264 = bool(data.get("force_h264", False))
        cookiefile = None
    else:
        url = (request.form.get("url") or "").strip()
        mode = request.form.get("mode", "single")
        choice = request.form.get("choice", "best")
        audio_format = request.form.get("audio_format", "mp3")
        force_h264 = request.form.get("force_h264") in ("true", "on", "1", "yes", "checked")
        cookiefile = request.files.get("cookiefile")

    if not url:
        return jsonify({"error": "No URL provided"}), 400

    task_id = str(uuid.uuid4())

    saved_cookie_path = None
    # If a cookie file was uploaded, validate and save it
    if cookiefile and cookiefile.filename:
        filename = secure_filename(cookiefile.filename)
        _, ext = os.path.splitext(filename)
        if ext.lower() not in ALLOWED_COOKIE_EXTS:
            return jsonify({"error": "Unsupported cookie file extension; upload a .txt (Netscape) cookies file"}), 400
        saved_cookie_name = f"cookies_{task_id}.txt"
        saved_cookie_path = os.path.join(DOWNLOAD_DIR, saved_cookie_name)
        cookiefile.save(saved_cookie_path)
        try:
            os.chmod(saved_cookie_path, 0o600)
        except Exception:
            pass

    task = {
        'id': task_id,
        'url': url,
        'mode': mode,
        'choice': choice,
        'audio_format': audio_format,
        'force_h264': force_h264,
        'cookiefile_path': saved_cookie_path,   # may be None
        'status': 'queued',
        'progress': {'status': 'queued'},
        'files': []
    }
    tasks[task_id] = task
    task_queue.put(task_id)
    return jsonify({"task_id": task_id}), 200


@app.route("/task_status/<task_id>")
def task_status(task_id):
    t = tasks.get(task_id)
    if not t:
        return jsonify({"error": "task not found"}), 404
    return jsonify({
        'id': t['id'],
        'status': t.get('status'),
        'progress': t.get('progress'),
        'files': t.get('files'),
        'error': t.get('error')
    })

@app.route("/downloads/<path:filename>")
def download_file(filename):
    return send_from_directory(DOWNLOAD_DIR, filename, as_attachment=True)

@app.route("/list_downloads")
def list_downloads():
    files = []
    for f in sorted(os.listdir(DOWNLOAD_DIR)):
        files.append(f)
    return jsonify({'files': files})

if __name__ == "__main__":
    app.run(debug=True, port=5000)
